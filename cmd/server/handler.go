package main

import (
	"html/template"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/sunboyy/lnurlauth/pkg"
)

// Handler contains all Gin handlers for this server.
type Handler struct {
	auth *Auth
}

// NewHandler is a constructor of Handler.
func NewHandler(auth *Auth) *Handler {
	return &Handler{
		auth: auth,
	}
}

// Home is a Gin handler for the index page. It has two conditions to show the
// page. If the user is not signed in, it will show the sign in page with
// the newly generated challenge information. Otherwise, it will display the
// page with signed in linking key information.
func (h *Handler) Home(c *gin.Context) {
	// Get session id from the request context.
	sessionIDIntf, ok := c.Get(sessionIDContextKey)
	if !ok {
		c.JSON(
			http.StatusInternalServerError,
			gin.H{"error": "unexpected a request context with no session id"},
		)
		return
	}

	sessionID, ok := sessionIDIntf.(string)
	if !ok {
		c.JSON(
			http.StatusInternalServerError,
			gin.H{"error": "unexpected session id with invalid type"},
		)
		return
	}

	linkingKey, ok := h.auth.LinkingKey(sessionID)
	if !ok {
		authChallenge, err := h.auth.Challenge(sessionID)
		if err != nil {
			c.JSON(
				http.StatusInternalServerError,
				gin.H{"error": err.Error()},
			)
			return
		}

		c.HTML(http.StatusOK, "login.tmpl", authChallenge)
		return
	}

	c.HTML(http.StatusOK, "index.tmpl", gin.H{
		"LinkingKey": linkingKey,
	})
}

// Login is a Gin handler to handle the request with signed k1 challenge from
// Lightning wallet application according to the LUD-04 RFC. The following query
// params must be set:
//   - tag: fixed value "login"
//   - k1: the random challenge previously generated by the system
//   - key: the identity of the user as public key (linking key)
//   - sig: the signature that verifies the identity of the user
func (h *Handler) Login(c *gin.Context) {
	// From the RFC (https://github.com/fiatjaf/lnurl-rfc/blob/luds/04.md), the
	// request must have the query `tag` to `login`.
	if c.Query("tag") != "login" {
		c.JSON(
			http.StatusBadRequest,
			createErrorResponse("query parameter `tag` is not 'login'"),
		)
		return
	}

	k1 := c.Query("k1")
	linkingKey := c.Query("key")
	signature := c.Query("sig")

	// Perform login using the provided information in the query parameters.
	if err := h.auth.Login(k1, linkingKey, signature); err != nil {
		c.JSON(http.StatusBadRequest, createErrorResponse(err.Error()))
		return
	}

	c.JSON(http.StatusOK, pkg.LNURLAuthResponse{
		Status: pkg.LNURLAuthResponseStatusOK,
	})
}

// Logout is a Gin handler for logging the user out. It logs the user out from
// the authentication service, removes session ID from the request cookie and
// then redirects the user to the index page.
func (h *Handler) Logout(c *gin.Context) {
	// Always redirect to home screen.
	defer c.Redirect(http.StatusTemporaryRedirect, "/")

	sessionIDIntf, ok := c.Get(sessionIDContextKey)
	if !ok {
		return
	}

	sessionID, ok := sessionIDIntf.(string)
	if !ok {
		return
	}

	// Remove session ID from the authentication service.
	h.auth.Logout(sessionID)

	// Unset session ID cookie.
	c.SetCookie(sessionKey, "", sessionAge, "/", c.Request.Host, false, true)
}

// safeURL converts a URL of type `string` to the URL of type `template.URL` so
// that the URL can be used on the HTML template.
func safeURL(url string) template.URL {
	return template.URL(url)
}

// createErrorResponse creates a struct of response body that comply to the
// LNURL-auth standard in the case that authentication fails or an error occurs.
func createErrorResponse(reason string) pkg.LNURLAuthResponse {
	return pkg.LNURLAuthResponse{
		Status: pkg.LNURLAuthResponseStatusError,
		Reason: reason,
	}
}
